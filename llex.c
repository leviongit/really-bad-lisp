#include "llex.h"
#include "malloc.h"

Lexer *lisp_lexer_construct(char const *const src, size_t len, Arena *arena) {
	if (arena == nullptr) {
		arena = arena_construct((u64)1 << 32);
	}

	Lexer *lexer = malloc(sizeof(Lexer));
	*lexer = (Lexer) {
		.src = src,
		.len =len,
		.idx = 0,
		.arena = arena,
		.token_list_fst = nullptr,
		.token_list_curr = nullptr
	};

	return lexer;
}

void lisp_lexer_destroy(Lexer *lexer) {
	TokenList *next_token_list_to_free = lexer->token_list_fst;

	while (next_token_list_to_free != nullptr) {
		TokenList *next_next_token_list = next_token_list_to_free->next;
		free(next_token_list_to_free);
		next_token_list_to_free = next_next_token_list;
	}

	free(lexer);
}

#define IDENT_BEGIN_BIT 0x01
#define IDENT_CONT_BIT 0x02
#define BINARY_LIT_BIT 0x04
#define OCTAL_LIT_BIT 0x08
#define DECIMAL_LIT_BIT 0x10
#define HEX_LIT_BIT 0x20
#define WHITESPACE_BIT 0x80

#define CHAR_CLASS_BY_PROPTBL_P(CHAR, MASK) chrprop_tbl[(u8)CHAR] & MASK

#define IS_IDENT_BEGIN_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, IDENT_BEGIN_BIT)
#define IS_IDENT_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, IDENT_CONT_BIT)
#define IS_BINARY_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, BINARY_LIT_BIT)
#define IS_OCTAL_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, OCTAL_LIT_BIT)
#define IS_DECIMAL_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, DECIMAL_LIT_BIT)
#define IS_HEX_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, HEX_LIT_BIT)
#define IS_WHITESPACE_P(CHAR) CHAR_CLASS_BY_PROPTBL_P(CHAR, WHITESPACE_BIT)

/* utf8 begone
 * here be magic numbers (bitmasks)
 * w_hdobIi
 * i - ident-begin
 * I - ident-continue
 * b - binary
 * o - octal
 * d - decimal
 * h - hex
 * _
 * w - whitespace
 */
// clang-format off
static const char chrprop_tbl[256] = {
  /* hV l> 0-VV  1-VV  2-VV  3-VV  4-VV  5-VV  6-VV  7-VV  8-VV  9-VV  a-VV  b-VV  c-VV  d-VV  e-VV  f-VV */
  /*  0 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
  /*  1 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  2 */ 0x80, 0x03, 0x00, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x03,
  /*  3 */ 0x3e, 0x3e, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x32, 0x32, 0x03, 0x00, 0x03, 0x03, 0x03, 0x03,
  /*  4 */ 0x03, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
  /*  5 */ 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03,
  /*  6 */ 0x00, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
  /*  7 */ 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,
  /*  8 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  9 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  a */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  b */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  c */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  d */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  e */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  /*  f */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
// clang-format on

bool lisp_lexer_is_ws(char c) { return IS_WHITESPACE_P(c); }
bool lisp_lexer_is_ident_begin(char c) { return IS_IDENT_BEGIN_P(c); }
bool lisp_lexer_is_ident(char c) { return IS_IDENT_P(c); }
bool lisp_lexer_is_bin_num(char c) { return IS_BINARY_P(c); }
bool lisp_lexer_is_oct_num(char c) { return IS_OCTAL_P(c); }
bool lisp_lexer_is_dec_num(char c) { return IS_DECIMAL_P(c); }
bool lisp_lexer_is_hex_num(char c) { return IS_HEX_P(c); }

Token lisp_lexer_lex1(Lexer *lexer) {}
TokenList *lisp_lexer_lex_all(Lexer *lexer) {}
